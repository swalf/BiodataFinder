#!/usr/bin/env ruby
#
# This is a Sinatra web interface for BiodataFinder
#
# Author::    Alessandro Bonfanti  (mailto:swalf@users.noreply.github.com)
# Copyright:: Copyright (c) 2014, Alessandro Bonfanti
# License::   GNU GPLv3

require 'sinatra'
require 'sass'
if development?
	require_relative '../lib/bdf-finder.rb'
	#require 'sinatra/reloader'
else
	require 'bdf-finder'
end
$def_index = "a10dic"
$indexes = ["a10dic"]

#Error classes:
class BdfSIError < RuntimeError
end

class QueryError < BdfSIError
end
#End error classes

class BdfSI < Sinatra::Base



configure do
	set :port, 1234
	#set :root, "../app/"
	set :root, "/home/swalf/Documenti/BioDataFinder/app/" #Why relative path do no more work? 
	enable :session
	
end

get ('/styles.css') { scss :styles }

get '/' do
    redirect to("/search")
end

get '/search' do
    @title = "BDF search"
    @search
    erb :search
end

get '/hello/:name' do
name = params[:name]
"Hi there #{name}!"
end

get '/query/:sstr' do
	begin
		raise QueryError.new("Malformed query!") unless params[:sstr] =~ /q=\w+(&\w{3}=\w+)*/
		str_split = params[:sstr].split('&')
		@searched = (str_split[0])[2..-1]
		str_split.shift
		@options = str_split.inject(Hash.new) do |opt_hash, str_opt|
			opt_name = str_opt[1..3].to_sym
			opt_hash[opt_name] = str_opt[5..-1]
		end	
		
		@options[:idx] = $def_index if @options[:idx].nil?
		@options[:out] = 'table' if @options[:out].nil?
		
		@title = "Results for '#{@searched}' in '#{@options[:idx]}'"
		
		client = (Elasticsearch::Client.new)
		raise "'#{@options[:idx]}' is not a valid index!" unless $indexes.include? @options[:idx]
		finder = Finder.new(client, @options[:idx])
		results = (finder.query @searched)
		@res_preamble = (
			if results.any?
				 "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
			else
				 "Sorry, I can't find anything for this search terms."
			end
		)	
			
		case @options[:out]
		when 'table'
			@tables = Array.new
			table = {headers: (results[:objs].first)[:data].keys, data: []}
			results[:objs].each_with_index do |obj,i|
				if obj[:data].keys == table[:headers]
					table[:data] << obj[:data].values
				else
					@tables << table
					table = Hash.new
					table[:headers] = obj[:data].keys
					table[:data] = [obj[:data].values]
				end
			end
			@tables << table
			erb :restable
		when 'pretty_json'
			JSON.pretty_generate( results )
		when 'json'
			JSON.generate( results )
		end
	rescue Faraday::ConnectionFailed => e
		@es_error = "It seems that there is no running istance of ElasticSearch, plese start it before use bdf-si."
		erb :es_error
	rescue Elasticsearch::Transport::Transport::Errors::NotFound => e
		@es_error = "'#{@sindex}' is not a valid index!"
		erb :es_error
	rescue Elasticsearch::Transport::Transport::Errors::BadRequest => e
		@es_error = "'#{@searched}' this is not a valid search (do not fill it only by delimiters)!"
		erb :es_error
	rescue Elasticsearch::Transport::Transport::Error => e
		@es_error = "ElasticSearch error occurred: #{e.message}"
		erb :es_error
	rescue QueryError => e
		@es_error = "A problem with your query has occurred: #{e.message}"
	rescue RuntimeError => e
		@es_error = e.message
		erb :es_error
	end	
end

post '/results' do
    begin
        @title = "Results for '#{params[:search]}'"
        @searched = params[:search].to_s
        client = (Elasticsearch::Client.new)
        @sindex = params[:index] || $def_index || (raise "I can't know in which index I have to search!")
        raise "'#{@sindex}' is not a valid index!" unless $indexes.include? @sindex
        finder = Finder.new(client, @sindex)
        results = (finder.query @searched)
        @res_preamble = (
        	if results.any?
				 "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
			else
				 "Sorry, I can't find anything for this search terms."
			end
		)	
			
		case params[:of]
		when 'table'
			@tables = Array.new
			table = {headers: (results[:objs].first)[:data].keys, data: []}
			results[:objs].each_with_index do |obj,i|
				if obj[:data].keys == table[:headers]
					table[:data] << obj[:data].values
				else
					@tables << table
					table = Hash.new
					table[:headers] = obj[:data].keys
					table[:data] = [obj[:data].values]
				end
			end
			@tables << table
			erb :restable
		when 'pretty_json'
			JSON.pretty_generate( results )
		when 'json'
			JSON.generate( results )
		end	
#		unless results.any? 
#			@res_preamble = "Sorry, I can't find anything for this search terms."
#			erb :results
#		else
#			@res_preamble = "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
#			unless params[:of] == 'table'
#        		results[:objs].each_with_index do |obj,i|
#					@str_res << "<p>Result #{i+1} (score #{obj[:infos][:scores]}):\n</p>"
#					@str_res << obj[:data]
#				end
#				erb :results
#			else
#				
#			end			
#		end
    rescue Faraday::ConnectionFailed => e
    	@es_error = "It seems that there is no running istance of ElasticSearch, plese start it before use bdf-si."
        erb :es_error
    rescue Elasticsearch::Transport::Transport::Errors::NotFound => e
    	@es_error = "'#{@sindex}' is not a valid index!"
    	erb :es_error
    rescue Elasticsearch::Transport::Transport::Errors::BadRequest => e
    	@es_error = "'#{@searched}' this is not a valid search (do not fill it only by delimiters)!"
    	erb :es_error
    rescue Elasticsearch::Transport::Transport::Error => e
    	@es_error = "ElasticSearch error occurred: #{e.message}"
    	erb :es_error
    rescue RuntimeError => e
    	@es_error = e.message
    	erb :es_error
    end
end

get '/options' do
	"<h3>Work in progress</h3>"
end

get '/about' do
    erb :about
end

not_found do
    erb :not_found
end

run!

end #class





