#!/usr/bin/env ruby
#
# This is a Sinatra web interface for BiodataFinder
#
# Author::    Alessandro Bonfanti  (mailto:swalf@users.noreply.github.com)
# Copyright:: Copyright (c) 2014, Alessandro Bonfanti
# License::   GNU GPLv3

require 'sinatra'
require 'sass'
require 'tempfile'

if development?
	require_relative '../lib/bdf-finder.rb'
	#require 'sinatra/reloader'
else
	require 'bdf-finder'
end
$def_index = "a10dic"
$indexes = ["a10dic"]

#Error classes:
class BdfSIError < RuntimeError
end

class QueryError < BdfSIError
end
#End error classes

class BdfSI < Sinatra::Base



	configure do
		set :port, 1234
		set :root, File.expand_path(File.dirname(__FILE__)) + "/../app/"
		enable :session
		
	end
	
	get ('/styles.css') { scss :styles }
	
	get '/' do
	    redirect to("/search")
	end
	
	get '/search' do
	    @title = "BDF search"
	    @search
	    erb :search
	end
	
	
	get '/search/q' do
		begin
			raise QueryError.new("Malformed query!") if @params[:src].nil?
			
			@params[:idx] = $def_index if @params[:idx].nil?
			@params[:out] = 'table' if @params[:out].nil?
			
			@title = "Results for '#{@params[:src]}' in '#{@params[:idx]}'"
			
			client = (Elasticsearch::Client.new)
			raise "'#{@params[:idx]}' is not a valid index!" unless $indexes.include? @params[:idx]
			finder = Finder.new(client, @params[:idx])
			results = (finder.query @params[:src])
			
			if results[:gen_infos][:nres] != 0	
				@res_preamble = "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
				case @params[:out]
				when 'table'
					@tables = Array.new
					table = Hash.new
					table[:headers] = (results[:objs].first)[:data].keys
					table[:data] =  []
					results[:objs].each_with_index do |obj,i|
						row = obj[:data].values
						if obj[:data].keys == table[:headers]
							table[:data] << row
						else
							@tables << table
							table = Hash.new
							table[:headers] = obj[:data].keys
							table[:data] = [row]
						end
					end
					@tables << table
					erb :restable
				when 'inline'
					@resultdata = Array.new
					results[:objs].each_with_index do |obj,i|
						data = Hash.new
						data[:number] = i
						data[:score] = obj[:infos][:scores]
						data[:filetype] = obj[:infos][:filetype]
						data[:filepath] = obj[:infos][:filepath]
						data[:headers] = obj[:data].keys
						data[:data] = obj[:data].values
						@resultdata << data
					end
					erb :search_inline
				when 'pretty_json'
					temp_json = Tempfile.new([params[:src],".json"])
					temp_json.puts  (JSON.pretty_generate results)
					temp_json.close
					send_file temp_json.path, :type => 'application/json', :disposition => 'attachment'
				when 'json'
					temp_json = Tempfile.new([params[:src],".json"])
					temp_json.puts  (JSON.generate results)
					temp_json.close
					send_file temp_json.path, :type => 'application/json', :disposition => 'attachment'
				else
					raise "An unknown output (#{@params[:out]}) has been requested."
				end
			else
				@res_preamble = "Sorry, I can't find anything for this search terms."
				erb :restable
			end
		rescue Faraday::ConnectionFailed => e
			@es_error = "It seems that there is no running instance of ElasticSearch, please start it before use bdf-si."
			erb :es_error
		rescue Elasticsearch::Transport::Transport::Errors::NotFound => e
			@es_error = "'#{@sindex}' is not a valid index!"
			erb :es_error
		rescue Elasticsearch::Transport::Transport::Errors::BadRequest => e
			@es_error = "'#{@searched}' this is not a valid search (do not fill it only by delimiters)!"
			erb :es_error
		rescue Elasticsearch::Transport::Transport::Error => e
			@es_error = "ElasticSearch error occurred: #{e.message}"
			erb :es_error
		rescue QueryError => e
			@es_error = "A problem with your query has occurred: #{e.message}"
		rescue RuntimeError => e
			@es_error = e.message
			erb :es_error
		end	
	end
	
	
	get '/options' do
		"<h3>Work in progress</h3>"
	end
	
	get '/about' do
	    erb :about
	end
	
	not_found do
	    erb :not_found
	end
	
	run!

end #class





