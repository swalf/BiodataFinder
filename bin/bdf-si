#!/usr/bin/env ruby
#
# This is a Sinatra web interface for BiodataFinder
#
# Author::    Alessandro Bonfanti  (mailto:swalf@users.noreply.github.com)
# Copyright:: Copyright (c) 2014, Alessandro Bonfanti
# License::   GNU GPLv3

require 'sinatra'
require 'slim'
require 'sass'
if development?
	require_relative '../lib/bdf-finder.rb'
	require 'sinatra/reloader'
else
	require 'bdf-finder'
end
$conf_file = ENV['HOME'] + "/.biodatafinder/bdf.conf"

begin
	unless File.exist? $conf_file
		raise "I can't find config file!"
	end
	File.open($conf_file,"r") do |file|
		file.each do |line|
			next if line[0] == '#'
			key, value = line.split(':') 
			case key
			when "def_index"
				$def_index = value.downcase.chomp
			when "indexes"
				value[-1]="" if value[-1] == "\n"
				$indexes = value.split(',')
			when "sinatra_def_output"
				@sinatra_def_output = value.downcase.chomp
			else 
				raise "Config file entain wrong fields!"
			end
		end
	end	
end
#il caricamento dovrebbe essere effettuato ogni volta che viene modificato il file di configurazione.

class BdfSI < Sinatra::Base



configure do
	set :port, 1234
	set :root, "../app/"
	enable :session
	
end

get ('/styles.css') { scss :styles }

get '/' do
    @title = "BiodataFinder - Home"
    slim :home
end

get '/about' do
    slim :about
end
get '/search' do
    @title = "BDF search"
    @search
    slim :search
end

post '/results' do
    begin
        @title = "Results for '#{params[:search]}'"
        @searched = params[:search].to_s
        client = (Elasticsearch::Client.new)
        @sindex = params[:index] || $def_index || (raise "I can't know in which index I have to search!")
        raise "'#{@sindex}' is not a valid index!" unless $indexes.include? @sindex
        finder = Finder.new(client, @sindex)
        results = (finder.query @searched)
        @res_preamble = (
        	if results.any?
				 "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
			else
				 "Sorry, I can't find anything for this search terms."
			end
		)	
			
		case params[:of]
		when 'table'
			@tables = Array.new
			table = {headers: (results[:objs].first)[:data].keys, data: []}
			results[:objs].each_with_index do |obj,i|
				if obj[:data].keys == table[:headers]
					table[:data] << obj[:data].values
				else
					@tables << table
					table = Hash.new
					table[:headers] = obj[:data].keys
					table[:data] = [obj[:data].values]
				end
			end
			@tables << table
			erb :restable
		when 'pretty_json'
			JSON.pretty_generate( results )
		when 'json'
			JSON.generate( results )
		end	
#		unless results.any? 
#			@res_preamble = "Sorry, I can't find anything for this search terms."
#			slim :results
#		else
#			@res_preamble = "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
#			unless params[:of] == 'table'
#        		results[:objs].each_with_index do |obj,i|
#					@str_res << "<p>Result #{i+1} (score #{obj[:infos][:scores]}):\n</p>"
#					@str_res << obj[:data]
#				end
#				slim :results
#			else
#				
#			end			
#		end
    rescue Faraday::ConnectionFailed => e
    	@es_error = "It seems that there is no running istance of ElasticSearch, plese start it before use bdf-si."
        slim :es_error
    rescue Elasticsearch::Transport::Transport::Errors::NotFound => e
    	@es_error = "'#{@sindex}' is not a valid index!"
    	slim :es_error
    rescue Elasticsearch::Transport::Transport::Errors::BadRequest => e
    	@es_error = "'#{@searched}' this is not a valid search (do not fill it only by delimiters)!"
    	slim :es_error
    rescue Elasticsearch::Transport::Transport::Error => e
    	@es_error = "ElasticSearch error occurred: #{e.message}"
    	slim :es_error
    rescue RuntimeError => e
    	@es_error = e.message
    	slim :es_error
    end
end

not_found do
    erb :not_found
end

run!

end #class




