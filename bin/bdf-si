#!/usr/bin/env ruby
#
# This is a Sinatra web interface for BiodataFinder
#
# Author::    Alessandro Bonfanti  (mailto:swalf@users.noreply.github.com)
# Copyright:: Copyright (c) 2014, Alessandro Bonfanti
# License::   GNU GPLv3

require 'sinatra'
require 'sass'
require "sinatra/json"
require "sinatra/cookies"


if development?
	require_relative '../lib/biodatafinder.rb'
	#require 'sinatra/reloader'
else
	require 'bdf_client'
end


i = 0
set_completed = false
while !set_completed
	unless ARGV[i].nil?
		argn, value = ARGV[i].split('=')
		case argn
		when 'port'
			$si_port = value.to_i
		when 'es_address'
			$host = value
		when 'bdf_index'
			$index = value
		end
	else
		
		$si_port = 1234 if $si_port.nil?
		$host = "localhost:9220" if $host.nil?
		$index = "biodatafinder_01" if $index.nil?
		BiodataFinder::Client.new $host, $index, true
		set_completed = true
	end
	i += 1
end
			



#Error classes:
class BdfSIError < RuntimeError
end

class QueryError < BdfSIError
end
#End error classes

class BdfSI < Sinatra::Base
	
	helpers Sinatra::Cookies
	



	configure do
		set :port, $si_port
		set :root, File.expand_path(File.dirname(__FILE__)) + "/../app/"
		enable :sessions
		set :bind, '0.0.0.0'
	end
	
	get ('/styles.css') { scss :styles }
	
	get '/' do
	    redirect to("/search")
	end
	
	get '/search' do
	    @title = "BDF search"
	    @search
	    erb :search
	end
	
	
	get '/search/q' do
		begin
			raise QueryError.new("Malformed query!") if @params[:src].nil?
			
			
			
			@params[:out] = 'table' if @params[:out].nil?
			
			@title = "Results for '#{@params[:src]}' in '#{$index}'"
			
			bdf_client = (BiodataFinder::Client.new $host, $index, true)
			
			
			results = (bdf_client.search @params[:src], {max_results: 25})
			
			
			case @params[:out]
			when 'table'
				if results[:gen_infos][:nres] != 0
					@res_preamble = "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
					@tables = Array.new
					table = Hash.new
					table[:headers] = (results[:objs].first)[:data].keys
					table[:data] =  []
					results[:objs].each_with_index do |obj,i|
						row = obj[:data].values
						if obj[:data].keys == table[:headers]
							table[:data] << row
						else
							@tables << table
							table = Hash.new
							table[:headers] = obj[:data].keys
							table[:data] = [row]
						end
					end
					@tables << table
					erb :restable
				else
					@res_preamble = "Sorry, I can't find anything for this search terms."
					erb :restable
				end
			when 'inline'
				if results[:gen_infos][:nres] != 0
					@res_preamble = "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
					@resultdata = Array.new
					results[:objs].each_with_index do |obj,i|
						data = Hash.new
						data[:number] = i
						data[:score] = obj[:infos][:scores]
						data[:filetype] = obj[:infos][:filetype]
						data[:filepath] = obj[:infos][:filepath]
						data[:headers] = obj[:data].keys
						data[:data] = obj[:data].values
						@resultdata << data
					end
					erb :search_inline
				else
					@res_preamble = "Sorry, I can't find anything for this search terms."
					erb :restable
				end
			when 'pretty_json'
				content_type :json
				JSON.pretty_generate results
			when 'json'
				content_type :json
				JSON.generate results
			else
				raise "An unknown output (#{@params[:out]}) has been requested."
			end
			
		rescue Faraday::ConnectionFailed => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "It seems that there is no running instance of ElasticSearch, please start it before use bdf-si."
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "No ElasticSearch instance found" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)		
			end
		rescue Elasticsearch::Transport::Transport::Errors::NotFound => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "'#{$index}' is not a valid index!"
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "'#{$index}' is not a valid index!" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)
			end
			
		rescue Elasticsearch::Transport::Transport::Errors::BadRequest => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "'#{@params[:src]}' this is not a valid search (do not fill it only by delimiters)! <#{e.message}>"
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "'#{@params[:src]}' is not a valid search" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)
			end
			
		rescue Elasticsearch::Transport::Transport::Error => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "ElasticSearch error occurred: #{e.message}"
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "ElasticSearch error: #{e.message}" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)
			end
			
		rescue QueryError => e
			@es_error = "A problem with your query has occurred: #{e.message}"
			
		rescue RuntimeError => e
			@es_error = e.message
			erb :es_error
		end	
	end
	
	
	get '/options' do
		@title = "BDF Options"
		erb :options
	end
	
	get '/options/s' do
		
		puts "params:", @params.to_s
		response.set_cookie 'index', {value: $index, max_age: "2592000"}
		response.set_cookie 'wildcards', {value: @params[:wildcards], max_age: "2592000"}
		response.set_cookie 'nres', {value: @params[:nres], max_age: "2592000"}
		response.set_cookie 'def_out', {value: @params[:def_out], max_age: "2592000"}
		puts "cookies: ", request.cookies.to_s 
		erb :options_saved
	end
	
	get '/about' do
	    erb :about
	end
	
	get '/wcookie' do
		response.set_cookie 'provac', {value: "Ciao!", max_age: "2592000"}
		
	end
	
	get '/rcookie' do
		request.cookies['provac']
		puts "cookies: ", request.cookies.to_s
	end
	
	not_found do
	    erb :not_found
	end
	
	run!

end #class





