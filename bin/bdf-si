#!/usr/bin/env ruby
#
# This is a Sinatra web interface for BiodataFinder
#
# Author::    Alessandro Bonfanti  (mailto:swalf@users.noreply.github.com)
# Copyright:: Copyright (c) 2014, Alessandro Bonfanti
# License::   GNU GPLv3

require 'sinatra'
require 'sass'
require 'tempfile'
require "sinatra/json"

if development?
	require_relative '../lib/bdf-finder.rb'
	#require 'sinatra/reloader'
else
	require 'bdf-finder'
end
$si_port = ARGV[0] || "1234"
$host = ARGV[1] || "localhost:9220"
$def_index = ARGV[2] || "ixd19dec14"
$indexes = ARGV[3].nil? ? ["idx19dec14", $def_index].uniq : ARGV[3].split(',')



#Error classes:
class BdfSIError < RuntimeError
end

class QueryError < BdfSIError
end
#End error classes

class BdfSI < Sinatra::Base



	configure do
		set :port, $port
		set :root, File.expand_path(File.dirname(__FILE__)) + "/../app/"
		enable :session
		
	end
	
	get ('/styles.css') { scss :styles }
	
	get '/' do
	    redirect to("/search")
	end
	
	get '/search' do
	    @title = "BDF search"
	    @search
	    erb :search
	end
	
	
	get '/search/q' do
		begin
			raise QueryError.new("Malformed query!") if @params[:src].nil?
			
			@params[:idx] = $def_index if @params[:idx].nil?
			@params[:out] = 'table' if @params[:out].nil?
			
			@title = "Results for '#{@params[:src]}' in '#{@params[:idx]}'"
			
			client = (Elasticsearch::Client.new host: $host, log: false)
			raise Elasticsearch::Transport::Transport::Errors::NotFound.new "'#{@params[:idx]}' is not a valid index!" unless $indexes.include? @params[:idx]
			finder = Finder.new(client, @params[:idx])
			results = (finder.query @params[:src])
			
			
			case @params[:out]
			when 'table'
				if results[:gen_infos][:nres] != 0
					@res_preamble = "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
					@tables = Array.new
					table = Hash.new
					table[:headers] = (results[:objs].first)[:data].keys
					table[:data] =  []
					results[:objs].each_with_index do |obj,i|
						row = obj[:data].values
						if obj[:data].keys == table[:headers]
							table[:data] << row
						else
							@tables << table
							table = Hash.new
							table[:headers] = obj[:data].keys
							table[:data] = [row]
						end
					end
					@tables << table
					erb :restable
				else
					@res_preamble = "Sorry, I can't find anything for this search terms."
					erb :restable
				end
			when 'inline'
				if results[:gen_infos][:nres] != 0
					@res_preamble = "#{results[:gen_infos][:nres]} result(s) found (max score #{results[:gen_infos][:max_scores]}):\n"
					@resultdata = Array.new
					results[:objs].each_with_index do |obj,i|
						data = Hash.new
						data[:number] = i
						data[:score] = obj[:infos][:scores]
						data[:filetype] = obj[:infos][:filetype]
						data[:filepath] = obj[:infos][:filepath]
						data[:headers] = obj[:data].keys
						data[:data] = obj[:data].values
						@resultdata << data
					end
					erb :search_inline
				else
					@res_preamble = "Sorry, I can't find anything for this search terms."
					erb :restable
				end
			when 'pretty_json'
				content_type :json
				JSON.pretty_generate results
			when 'json'
				content_type :json
				JSON.generate results
			else
				raise "An unknown output (#{@params[:out]}) has been requested."
			end
			
		rescue Faraday::ConnectionFailed => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "It seems that there is no running instance of ElasticSearch, please start it before use bdf-si."
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "No ElasticSearch istance found" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)		
			end
		rescue Elasticsearch::Transport::Transport::Errors::NotFound => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "'#{@params[:idx]}' is not a valid index!"
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "'#{@params[:idx]}' is not a valid index!" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)
			end
			
		rescue Elasticsearch::Transport::Transport::Errors::BadRequest => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "'#{@searched}' this is not a valid search (do not fill it only by delimiters)!"
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "'#{@searched}' is not a valid search" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)
			end
			
		rescue Elasticsearch::Transport::Transport::Error => e
			unless ["json", "pretty_json"].include? @params[:out] 
				@es_error = "ElasticSearch error occurred: #{e.message}"
				erb :es_error
			else
				results = { "status" => "error", "gen_infos" => {"error_type" => "ElasticSearch error: #{e.message}" }}
				content_type :json
				(@params[:out] == 'pretty_json') ? (JSON.pretty_generate results) : (JSON.generate results)
			end
			
		rescue QueryError => e
			@es_error = "A problem with your query has occurred: #{e.message}"
			
		rescue RuntimeError => e
			@es_error = e.message
			erb :es_error
		end	
	end
	
	
	get '/options' do
		"<h3>Work in progress</h3>"
	end
	
	get '/about' do
	    erb :about
	end
	
	not_found do
	    erb :not_found
	end
	
	run!

end #class





